# 4.x用户手册

### 前言

#### 问题

如今，我们使用目标通用的应用或库来进行相互间的通讯。例如，我们常使用HTTP客户端库来检索来自服务端的信息，并通过网络服务（web service）来进行一个远程过程调用。然而，一个通用目标的协议或者它的实现有时候并不能尽善尽美。就好像我们不会用一个通用目标的HTTP服务器来交换大型文件，电子邮件信息，以及近乎实时的信息如金融信息和多人游戏数据。这些都要求针对特定的目标来实现高度优化的协议。例如，你可能想要实现一个HTTP服务器能够针对基于Ajax聊天应用，流媒体或大型文件传输来优化。你甚至会想设计并实现一个全新的协议来为自己的需求精确的量身定做。另一个不可避免的场景是处理历史遗留的专用协议来保证和老系统的互通性。这个场景的重点在于如何能为目标应用在不牺牲稳定和性能的前提下快速的实现一个协议。

### 解决方案

Netty项目是一个提供异步时间驱动网络应用框架和快速开发可维护的高性能高扩展性服务端和客户端协议工具集的成果。

换句话说，Netty是一个NIO客户端服务端框架，它使得快速而简单的开发像服务端客户端协议的网络应用成为了可能。它它极大的简化并流线化了如TCP和UDP套接字服务器开发的网络编程。

“快速且简便”不意味着目标应用将容忍维护性和性能上的问题。Netty在吸取了大量协议实现（如FTP，SMTP，HTTP以及各种二进制，基于文本的传统协议）的经验上进行了精心的设计。由此，Netty成功找到了一个无需折衷妥协而让开发、性能、稳定性和灵活性相互协调的方法。

一些用户可能已经找到了其他的生成有同样有点的网络应用框架，并想知道Netty与这些有什么不同。答案是它所依赖的哲学。 Netty是设计来给你在API和实现上最佳体验的。它不是有迹可循的东西，但你在阅读这片指南将察觉这一哲学会让你玩Netty的生活变得更好过。

### 开始

这篇指南围绕着Netty的核心结构举出了几个例子来让你迅速上手。当你看完这篇文章后将能够立刻写出一个基于Netty的客户端和服务端。

如果你更喜欢自顶而下的学习方法，可以从第二篇开始，架构概览，然后返回到这里。

#### 开始之前

本篇文章所介绍的示例程序所需要的最小运行需求只有两点：最新版本的Netty和JDK 1.6及以上。最新版本的Netty可以在[项目下载页](http://netty.io/downloads.html)找到。

当你读的时候，可能对本篇介绍的这些类有很多疑问。当你想要深入了解这些时，请查询API手册。本篇文章里的所有类都会关联到在线API手册以便于你阅读。同时，如果你发现了有不对的信息，语法错误，排版错误或者你有提高这片文档的好主意，请务必果断[联系Netty项目社区](http://netty.io/community.html) 。

#### 写一个Discard服务器

在Netty的世界里，最简单的协议不是"Hello World!"，而是[DISCARD](http://tools.ietf.org/html/rfc863)。这个协议将丢弃任何接收到的数据，不做任何响应。

实现`DISCARD`协议要做的事情就是忽略所有接收到的数据。让我们直接从处理实现开始，它负责处理Netty产生的I/O事件。

```java
package io.netty.example.discard;
import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHanlderAdapter;
/**
 * 处理服务端通道
 */
public class DiscardServerHandler extends ChannelInboundHanderAdapter{ //(1)
  @Override
  public void channelRead(ChannelHandlerContext ctx,Object msg){ //(2)
    //默默的丢弃接收到的数据
    ((ByteBuf) msg).release(); //(3)
  }
  @Override
  public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause){ //(4)
    //出现异常时关闭链接
    cause.printStackTrace();
    ctx.close();
  }
}
```

1. `DiscardServerHandler`继承了 [`ChannelInboundHandlerAdapter`](http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandlerAdapter.html)，它是[`ChannelInboundHandler`](http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandler.html)的一个实现。`ChannelInboundHandler`提供了各种事件处理方法供你重写。目前，它只需要继承`ChannelInboundHandlerAdapter`而不用自己实现处理接口。

2. 我们重写了`channelRead()`事件处理方法。这个方法将在接收到信息时被调用，无论何时从客户端接收到新的数据。在这个例子中，接收的信息的数据类型是[`ByteBuf`](http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html)。

3. 为了实现`DISCARD`协议，处理器需忽略接收到的信息。`ByteBuf`是一个引用计数对象，它需要通过`release()`方法进行显示的释放。请牢记，释放一切传递给处理器的引用计数对象是处理器应尽的责任。通常，`channelRead()`处理方法像如下这样实现：

   ```java
   @Override
   public void channelRead(ChannelHandlerContext ctx,Object msg){
    try{
      //对msg做些什么
    } finally{
      ReferenceCountUtil.release(msg);
    }
   }
   ```

4. 当Netty因为I/O错误或处理器实现在进行事件处理中抛出异常时，将会调用`exceptionCaught()`方法事件处理。虽然这个方法的实现会根据你对于异常情况下的处理而有所不同，但在大多数情况下，对被获取的异常应该记录日志，关闭与之相关的通道。例如，你可能想要在关闭连接之前发送一个包含错误码的响应信息。

