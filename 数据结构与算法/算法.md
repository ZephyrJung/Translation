# 算法

> 本文为从各个书籍、资料阅读后总结出来的算法描述，将不涉及实现部分（顶多带有部分代码说明），旨在理解算法的原理，核心。

## 排序和搜索

### 插入排序

插入排序每次从无序数据集中取出一个元素，扫描已排好序的数据集，并将它插入有序集合合适的位置上。乍一看需要预留足够的存储空间，但实际上并不需要额外的存储空间。

它在处理大型数据集时并不高效，因为被插入的元素需要和有序集中的其他元素进行比较，这会随着数据集的增大而增加额外的开销。其优点是，最多进行一次遍历，而且不需要完整的运行算法，这个特性使得插入排序在增量排序中非常高效。

### 快速排序

快速排序是一种分治排序算法。其本质过程就是不断地将无序元素集递归分割，直到所有的分区都只包含单个元素。

可将为排序的支票分为两堆。其中一堆专门用于放小于或等于某个编号的支票，而另一堆用来放大于这个编号的支票。当以这种方式得到两堆支票后，又可以用同样的方式将它们分为四堆，不断重复这个过程直到每个堆中只放有一张支票。这时，所有支票就已经排好序了。

可以用分治法的思想将排序分为三个步骤：

- 分：设定一个分割值将数据分为两部分
- 治：分别在两部分用递归的方式继续使用快速排序算法
- 合：对分割部分排序至完成

所选的分割值需要尽可能将元素平均分开。一种行之有效的方法是通过随机选择发来选取。更进一步是随机选取三个元素，再选择三个元素中的中间值，这就是所谓的中位数方法。

### 归并排序

归并排序是另一种运用分治法排序的算法。需要额外的存储空间来完成排序过程。

首先，将为排序的支票对半分为两堆。接着分别又将两堆支票对半分为两堆，以此类推，重复此过程，直到每一堆支票只包含一张支票，然后开始将堆两两合并，这样每个合并出来的堆就是两个有序堆的合集，也是有序的。这个合并过程一直持续下去，直到一堆新的支票生成。此时，这堆支票就是有序的。

合并的过程不能在无序数据集本身中进行，所以必须要有两倍于无序数据集的空间来运行算法。按照预期将数据集分开，变成更加可管理的数据，接着用归并排序处理数据，然后不断地合并数据，在这个过程中不需要一次存储所有地数据。

​:question: 此处并未提及合并时采用了什么排序算法。归并排序似乎并不单纯……

### 计数排序

一种高效的线性排序，通过计算一个集合中元素出现的次数来确定集合如何排列，不需要进行元素比较。它只能用于整型或者那些可以用整形来表示的数据集合。

:question:

### 基数排序

另一种高效的线性排序算法，其方法是将数据按位分开，并从数据的最低有效位到最高有效位进行比较，依次排序，从而得到有序数据集合。如{15,12,49,16,36,40}排序，先对个位数排序得到{40,12,15,16,36,49}，在对十位进行排序，结果为{12,15,16,36,40,49}

:question:

### 二分查找

二分查找是对一个有序数据集合所做的操作。查找开始时，首先找出有序集合中间的那个元素，如果此元素比要查找的元素大，就接着在较小的一个半区进行查找，反之则在较大的半区查找，在每个更小的数据集中重复这个查找过程来缩小猜测的范围，直到猜出正确的数字。

## 数值计算

### 多项式插值法

### 最小二乘估计法

### 方程求解

## 数据压缩

### 位操作

### 霍夫曼编码

### LZ77

## 数据加密

### DES算法

### RSA算法

## 图算法

### 最小生成树

### 最短路径

### 旅行商问题

## 几何算法

### 测试线段是否相交

### 凸包

### 球面弧长